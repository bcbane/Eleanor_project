{"ast":null,"code":"import React from 'react';\nimport { ScrollProvider, ScrollConsumer } from '@stickyroll/context';\nimport { Tracker } from '@stickyroll/tracker';\nimport { hashCode, classNames } from '@stickyroll/utils';\nvar version = \"1.1.6\";\n/**\r\n * Styles for the core frame\r\n */\n\nconst styles = {\n  overlay: `\n\t\theight: 100vh;\n\t\tposition: -webkit-sticky;\n\t\tposition: sticky;\n\t\ttop: 0;\n\t\twidth: 100%;\n\t`,\n  skip: `\n\t\tposition: absolute; \n\t\ttop: 100%;\n\t`,\n  target: `\n\t\tdisplay: block; \n\t\theight: 100vh;\n\t`,\n  targets: `\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\t\tleft: 0;\n\t`,\n  wrapper: `\n\t\tposition: relative;\n\t\tmargin: 0;\n\t`\n};\n/**\r\n * Hashed classNames for styling\r\n */\n\nconst hashSelectors = {\n  wrapper: hashCode(`/* stickyroll-version: ${version} */\\n${styles.wrapper}`),\n  overlay: hashCode(`/* stickyroll-version: ${version} */\\n${styles.overlay}`),\n  targets: hashCode(`/* stickyroll-version: ${version} */\\n${styles.targets}`),\n  target: hashCode(`/* stickyroll-version: ${version} */\\n${styles.target}`),\n  skip: hashCode(`/* stickyroll-version: ${version} */\\n${styles.skip}`)\n};\n/**\r\n * Hashed and prefixed classNames for styling\r\n * (currently not in use, keep for future scope safety)\r\n */\n\nconst hashNSSelectors = {\n  wrapper: `sr-${hashCode(hashSelectors.wrapper)}`,\n  overlay: `sr-${hashCode(hashSelectors.overlay)}`,\n  targets: `sr-${hashCode(hashSelectors.targets)}`,\n  target: `sr-${hashCode(hashSelectors.target)}`,\n  skip: `sr-${hashCode(hashSelectors.skip)}`\n};\n/**\r\n * Hashed and hash-prefixed classNames combined\r\n */\n\nconst hashClassNames = {\n  wrapper: classNames(hashNSSelectors.wrapper, hashSelectors.wrapper),\n  overlay: classNames(hashNSSelectors.overlay, hashSelectors.overlay),\n  targets: classNames(hashNSSelectors.targets, hashSelectors.targets),\n  target: classNames(hashNSSelectors.target, hashSelectors.target),\n  skip: classNames(hashNSSelectors.skip, hashSelectors.skip)\n};\n/**\r\n * Core styling required to display the component correctly\r\n */\n\nconst CORE_STYLE = `\n\tbody {\n\t\tmargin-top: 0;\n\t\tmargin-bottom: 0;\n\t}\n\t.${hashSelectors.wrapper}{${styles.wrapper}}\n\t.${hashSelectors.overlay}{${styles.overlay}}\n\t.${hashSelectors.targets}{${styles.targets}}\n\t.${hashSelectors.target}{${styles.target}}\n\t.${hashSelectors.skip}{${styles.skip}}\n\t.${hashSelectors.wrapper}{${styles.wrapper}}\n`.replace(/\\s+/g, \"\").replace(/;}/g, \"}\");\n/**\r\n * The style tag needed to display the component correctly\r\n */\n\nconst CORE_STYLE_TAG = `<style data-stickyroll data-stickyroll-version=\"${version}\">${CORE_STYLE}</style>`;\n/**\r\n * Injects core styles for Stickyroll. This is the client side version.\r\n * Stickyroll will inject these styles to ensure the correct behavior.\r\n * @constructor\r\n */\n\nconst INJECT_CORE_STYLE = () => {\n  const existingStyle = document.head.querySelector(\"[data-stickyroll]\");\n\n  if (Boolean(existingStyle)) {\n    const styleVersion = existingStyle.getAttribute(\"data-stickyroll-version\");\n\n    if (styleVersion === version) {\n      document.head.appendChild(existingStyle);\n      return;\n    }\n  }\n\n  const style = document.createElement(\"style\");\n  style.setAttribute(\"data-stickyroll\", \"\");\n  style.setAttribute(\"data-stickyroll-version\", `${version}`);\n  style.innerHTML = CORE_STYLE;\n  document.head.appendChild(style);\n};\n\nclass Frame extends React.Component {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * @public\r\n     * @type {IFrameState}\r\n     */\n\n    this.state = {\n      page: 0,\n      scrollOffset: 0,\n      scrollY: 0\n    };\n    /**\r\n     * @private\r\n     * @type {React.RefObject<HTMLDivElement>}\r\n     */\n\n    this.tracker = React.createRef();\n    /**\r\n     * A Wrapper around the content to ensure the correct behavior during interaction.\r\n     * Renders a sticky container, an event-tracker and optionally anchor targets to allow deep-links.\r\n     * @constructor\r\n     * @private\r\n     * @type {React.FunctionComponent}\r\n     * @param props\r\n     * @return {ReactElement<any> | null}\r\n     */\n\n    this.Wrapper = ({\n      children\n    }) => React.createElement(React.Fragment, null, React.createElement(Tracker, {\n      onUpdate: this.handleUpdate,\n      throttle: this.props.throttle\n    }), React.createElement(\"div\", {\n      className: classNames(hashClassNames.wrapper, this.props.className),\n      ref: this.tracker,\n      style: this.wrapperStyle\n    }, this.anchors, React.createElement(\"div\", {\n      className: hashClassNames.overlay\n    }, children)));\n    /* istanbul ignore next */\n\n    /**\r\n     * Scroll handler to parse the page and progress from the scroll position.\r\n     * @private\r\n     * @param {number} scrollY\r\n     * @returns {void}\r\n     */\n\n\n    this.handleUpdate = scrollY => {\n      if (!this.tracker || !this.tracker.current) {\n        return;\n      }\n\n      let page = 0;\n      let scrollOffset = 0;\n      const {\n        top,\n        bottom\n      } = this.tracker.current.getBoundingClientRect();\n      const {\n        factor\n      } = this.props;\n      const {\n        innerHeight = 0\n      } = window;\n      const touchedTop = top <= 0;\n      const touchedEnd = bottom <= innerHeight;\n\n      if (touchedTop && !touchedEnd) {\n        page = Math.max(0, Math.min(this.pageCount - 1, Math.floor(top * (-1 / factor) / innerHeight)));\n        scrollOffset = Math.max(0, Math.min(1, top * -1 % (innerHeight * factor) / innerHeight / factor));\n      } else if (touchedEnd) {\n        page = this.pageCount - 1;\n        scrollOffset = 1;\n      }\n\n      this.setState({\n        page,\n        scrollOffset,\n        scrollY\n      });\n    };\n  }\n  /**\r\n   * @public\r\n   * @type {IFrameDefaultProps}\r\n   */\n\n\n  static get defaultProps() {\n    return {\n      factor: 1\n    };\n  }\n  /**\r\n   * Write the current scrollPosition to the internal state when the component is mounted.\r\n   * This will allow getting the correct page and progress after mounting.\r\n   * @public\r\n   */\n\n\n  componentDidMount() {\n    Frame.injectStyle();\n    this.setState({\n      scrollY: window.scrollY\n    });\n  }\n  /* istanbul ignore next */\n\n  /**\r\n   * Call the onPage handler if it is defined every time the page changes.\r\n   * No initial call!\r\n   * @public\r\n   */\n\n\n  componentDidUpdate(oldProps, oldState) {\n    const {\n      page,\n      scrollOffset\n    } = this.state;\n\n    if (oldState.page !== page) {\n      this.props.onPage && this.props.onPage(this.state.page);\n    }\n\n    if (oldState.scrollOffset !== scrollOffset) {\n      const zero = scrollOffset === 0;\n      const one = scrollOffset === 1;\n      const start = zero && page === 0;\n      const end = one && page === this.pageCount - 1;\n\n      if (start && this.props.onStart) {\n        this.props.onStart();\n      } else if (end && this.props.onEnd) {\n        this.props.onEnd();\n      }\n    }\n  }\n  /**\r\n   * Rendering can be configured in two different ways.\r\n   * 1. Using `children`:\r\n   *    * uses context\r\n   *    * supports context based plugins\r\n   * 2. Using `render`:\r\n   *    * better performance\r\n   *\r\n   * The differences are based on the use of context. To allow context based plugins it is advised\r\n   * to use a child function. To improve performance the render property can be used (Plugins can still be used but\r\n   * must be configured manually)\r\n   * @public\r\n   */\n\n\n  render() {\n    const {\n      render,\n      children,\n      anchors\n    } = this.props; // Test for either the render property or children to be defined as function.\n    // Render wins over children if both are defined. If neither is defined as function, a TypeError is thrown.\n\n    if (typeof render !== \"function\" && typeof children !== \"function\") {\n      throw new TypeError(`Either children or render needs to be defined as a function`);\n    }\n\n    const {\n      page\n    } = this.state;\n    const Wrapper = this.Wrapper; // Convert the scrollOffset from percent to a timeline [0,1]\n\n    const progress = this.state.scrollOffset; // const {innerHeight} = window;\n    // const clippedProgress = Math.round(progress * innerHeight) / innerHeight;\n    // Switch between context free and context based versions\n\n    switch (typeof render) {\n      case \"function\":\n        // Context free\n        return React.createElement(Wrapper, null, render({\n          anchors,\n          page: page + 1,\n          pageIndex: page,\n          pages: this.pageCount,\n          progress\n        }));\n      // Context based\n\n      default:\n        return React.createElement(ScrollProvider, {\n          value: {\n            anchors,\n            page: page + 1,\n            pageIndex: page,\n            pages: this.pageCount,\n            progress\n          }\n        }, React.createElement(Wrapper, null, React.createElement(ScrollConsumer, null, children)));\n    }\n  }\n\n  static injectStyle() {\n    INJECT_CORE_STYLE();\n  }\n\n  static getStyleTag() {\n    return CORE_STYLE_TAG;\n  }\n\n  static getStyle() {\n    return CORE_STYLE;\n  }\n\n  get pageCount() {\n    const {\n      pages\n    } = this.props;\n    return Array.isArray(pages) ? pages.length : pages;\n  }\n  /**\r\n   * @type {React.CSSProperties}\r\n   */\n\n\n  get wrapperStyle() {\n    const {\n      factor\n    } = this.props;\n    const vh = this.pageCount * 100 * factor + 100;\n    return {\n      height: `${vh}vh`\n    };\n  }\n  /**\r\n   * If anchors are defined, a collection of spans with the correct IDs are provided.\r\n   * This allows to link or jump to a section or even skip the entire content.\r\n   * @type {React.ReactElement<HTMLDivElement> | null}\r\n   */\n\n\n  get anchors() {\n    const {\n      anchors\n    } = this.props;\n\n    if (!(typeof anchors === \"string\")) {\n      return null;\n    }\n\n    const {\n      factor\n    } = this.props;\n    const glue = anchors.length ? \"/\" : \"\";\n    const targets = Array(this.pageCount).fill(Boolean).map((x, i) => React.createElement(\"span\", {\n      id: `${anchors}${glue}${i + 1}`,\n      key: `${anchors}:${i + 1}`,\n      className: hashClassNames.target,\n      style: {\n        height: `${100 * factor}vh`\n      }\n    }));\n    return React.createElement(\"div\", {\n      className: hashClassNames.targets\n    }, targets, React.createElement(\"span\", {\n      id: `${anchors}${glue}${this.pageCount + 1}`,\n      className: hashClassNames.target\n    }), React.createElement(\"span\", {\n      id: `${anchors}${glue}skip`,\n      className: hashClassNames.skip\n    }));\n  }\n\n}\n\nexport { CORE_STYLE, CORE_STYLE_TAG, Frame, hashClassNames };","map":{"version":3,"sources":["/Users/owner-mac/CODE/eleanor/eleanor/node_modules/@stickyroll/frame/dist/esm/index.js"],"names":["React","ScrollProvider","ScrollConsumer","Tracker","hashCode","classNames","version","styles","overlay","skip","target","targets","wrapper","hashSelectors","hashNSSelectors","hashClassNames","CORE_STYLE","replace","CORE_STYLE_TAG","INJECT_CORE_STYLE","existingStyle","document","head","querySelector","Boolean","styleVersion","getAttribute","appendChild","style","createElement","setAttribute","innerHTML","Frame","Component","constructor","arguments","state","page","scrollOffset","scrollY","tracker","createRef","Wrapper","children","Fragment","onUpdate","handleUpdate","throttle","props","className","ref","wrapperStyle","anchors","current","top","bottom","getBoundingClientRect","factor","innerHeight","window","touchedTop","touchedEnd","Math","max","min","pageCount","floor","setState","defaultProps","componentDidMount","injectStyle","componentDidUpdate","oldProps","oldState","onPage","zero","one","start","end","onStart","onEnd","render","TypeError","progress","pageIndex","pages","value","getStyleTag","getStyle","Array","isArray","length","vh","height","glue","fill","map","x","i","id","key"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { ScrollProvider, ScrollConsumer } from '@stickyroll/context';\nimport { Tracker } from '@stickyroll/tracker';\nimport { hashCode, classNames } from '@stickyroll/utils';\n\nvar version = \"1.1.6\";\n\n/**\r\n * Styles for the core frame\r\n */\r\nconst styles = {\r\n    overlay: `\n\t\theight: 100vh;\n\t\tposition: -webkit-sticky;\n\t\tposition: sticky;\n\t\ttop: 0;\n\t\twidth: 100%;\n\t`,\r\n    skip: `\n\t\tposition: absolute; \n\t\ttop: 100%;\n\t`,\r\n    target: `\n\t\tdisplay: block; \n\t\theight: 100vh;\n\t`,\r\n    targets: `\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\t\tleft: 0;\n\t`,\r\n    wrapper: `\n\t\tposition: relative;\n\t\tmargin: 0;\n\t`\r\n};\r\n/**\r\n * Hashed classNames for styling\r\n */\r\nconst hashSelectors = {\r\n    wrapper: hashCode(`/* stickyroll-version: ${version} */\\n${styles.wrapper}`),\r\n    overlay: hashCode(`/* stickyroll-version: ${version} */\\n${styles.overlay}`),\r\n    targets: hashCode(`/* stickyroll-version: ${version} */\\n${styles.targets}`),\r\n    target: hashCode(`/* stickyroll-version: ${version} */\\n${styles.target}`),\r\n    skip: hashCode(`/* stickyroll-version: ${version} */\\n${styles.skip}`)\r\n};\r\n/**\r\n * Hashed and prefixed classNames for styling\r\n * (currently not in use, keep for future scope safety)\r\n */\r\nconst hashNSSelectors = {\r\n    wrapper: `sr-${hashCode(hashSelectors.wrapper)}`,\r\n    overlay: `sr-${hashCode(hashSelectors.overlay)}`,\r\n    targets: `sr-${hashCode(hashSelectors.targets)}`,\r\n    target: `sr-${hashCode(hashSelectors.target)}`,\r\n    skip: `sr-${hashCode(hashSelectors.skip)}`\r\n};\r\n/**\r\n * Hashed and hash-prefixed classNames combined\r\n */\r\nconst hashClassNames = {\r\n    wrapper: classNames(hashNSSelectors.wrapper, hashSelectors.wrapper),\r\n    overlay: classNames(hashNSSelectors.overlay, hashSelectors.overlay),\r\n    targets: classNames(hashNSSelectors.targets, hashSelectors.targets),\r\n    target: classNames(hashNSSelectors.target, hashSelectors.target),\r\n    skip: classNames(hashNSSelectors.skip, hashSelectors.skip)\r\n};\r\n/**\r\n * Core styling required to display the component correctly\r\n */\r\nconst CORE_STYLE = `\n\tbody {\n\t\tmargin-top: 0;\n\t\tmargin-bottom: 0;\n\t}\n\t.${hashSelectors.wrapper}{${styles.wrapper}}\n\t.${hashSelectors.overlay}{${styles.overlay}}\n\t.${hashSelectors.targets}{${styles.targets}}\n\t.${hashSelectors.target}{${styles.target}}\n\t.${hashSelectors.skip}{${styles.skip}}\n\t.${hashSelectors.wrapper}{${styles.wrapper}}\n`\r\n    .replace(/\\s+/g, \"\")\r\n    .replace(/;}/g, \"}\");\r\n/**\r\n * The style tag needed to display the component correctly\r\n */\r\nconst CORE_STYLE_TAG = `<style data-stickyroll data-stickyroll-version=\"${version}\">${CORE_STYLE}</style>`;\r\n/**\r\n * Injects core styles for Stickyroll. This is the client side version.\r\n * Stickyroll will inject these styles to ensure the correct behavior.\r\n * @constructor\r\n */\r\nconst INJECT_CORE_STYLE = () => {\r\n    const existingStyle = document.head.querySelector(\"[data-stickyroll]\");\r\n    if (Boolean(existingStyle)) {\r\n        const styleVersion = existingStyle.getAttribute(\"data-stickyroll-version\");\r\n        if (styleVersion === version) {\r\n            document.head.appendChild(existingStyle);\r\n            return;\r\n        }\r\n    }\r\n    const style = document.createElement(\"style\");\r\n    style.setAttribute(\"data-stickyroll\", \"\");\r\n    style.setAttribute(\"data-stickyroll-version\", `${version}`);\r\n    style.innerHTML = CORE_STYLE;\r\n    document.head.appendChild(style);\r\n};\r\nclass Frame extends React.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * @public\r\n         * @type {IFrameState}\r\n         */\r\n        this.state = {\r\n            page: 0,\r\n            scrollOffset: 0,\r\n            scrollY: 0\r\n        };\r\n        /**\r\n         * @private\r\n         * @type {React.RefObject<HTMLDivElement>}\r\n         */\r\n        this.tracker = React.createRef();\r\n        /**\r\n         * A Wrapper around the content to ensure the correct behavior during interaction.\r\n         * Renders a sticky container, an event-tracker and optionally anchor targets to allow deep-links.\r\n         * @constructor\r\n         * @private\r\n         * @type {React.FunctionComponent}\r\n         * @param props\r\n         * @return {ReactElement<any> | null}\r\n         */\r\n        this.Wrapper = ({ children }) => (React.createElement(React.Fragment, null,\r\n            React.createElement(Tracker, { onUpdate: this.handleUpdate, throttle: this.props.throttle }),\r\n            React.createElement(\"div\", { className: classNames(hashClassNames.wrapper, this.props.className), ref: this.tracker, style: this.wrapperStyle },\r\n                this.anchors,\r\n                React.createElement(\"div\", { className: hashClassNames.overlay }, children))));\r\n        /* istanbul ignore next */\r\n        /**\r\n         * Scroll handler to parse the page and progress from the scroll position.\r\n         * @private\r\n         * @param {number} scrollY\r\n         * @returns {void}\r\n         */\r\n        this.handleUpdate = (scrollY) => {\r\n            if (!this.tracker || !this.tracker.current) {\r\n                return;\r\n            }\r\n            let page = 0;\r\n            let scrollOffset = 0;\r\n            const { top, bottom } = this.tracker.current.getBoundingClientRect();\r\n            const { factor } = this.props;\r\n            const { innerHeight = 0 } = window;\r\n            const touchedTop = top <= 0;\r\n            const touchedEnd = bottom <= innerHeight;\r\n            if (touchedTop && !touchedEnd) {\r\n                page = Math.max(0, Math.min(this.pageCount - 1, Math.floor((top * (-1 / factor)) / innerHeight)));\r\n                scrollOffset = Math.max(0, Math.min(1, ((top * -1) % (innerHeight * factor)) / innerHeight / factor));\r\n            }\r\n            else if (touchedEnd) {\r\n                page = this.pageCount - 1;\r\n                scrollOffset = 1;\r\n            }\r\n            this.setState({\r\n                page,\r\n                scrollOffset,\r\n                scrollY\r\n            });\r\n        };\r\n    }\r\n    /**\r\n     * @public\r\n     * @type {IFrameDefaultProps}\r\n     */\r\n    static get defaultProps() {\r\n        return {\r\n            factor: 1\r\n        };\r\n    }\r\n    /**\r\n     * Write the current scrollPosition to the internal state when the component is mounted.\r\n     * This will allow getting the correct page and progress after mounting.\r\n     * @public\r\n     */\r\n    componentDidMount() {\r\n        Frame.injectStyle();\r\n        this.setState({\r\n            scrollY: window.scrollY\r\n        });\r\n    }\r\n    /* istanbul ignore next */\r\n    /**\r\n     * Call the onPage handler if it is defined every time the page changes.\r\n     * No initial call!\r\n     * @public\r\n     */\r\n    componentDidUpdate(oldProps, oldState) {\r\n        const { page, scrollOffset } = this.state;\r\n        if (oldState.page !== page) {\r\n            this.props.onPage && this.props.onPage(this.state.page);\r\n        }\r\n        if (oldState.scrollOffset !== scrollOffset) {\r\n            const zero = scrollOffset === 0;\r\n            const one = scrollOffset === 1;\r\n            const start = zero && page === 0;\r\n            const end = one && page === this.pageCount - 1;\r\n            if (start && this.props.onStart) {\r\n                this.props.onStart();\r\n            }\r\n            else if (end && this.props.onEnd) {\r\n                this.props.onEnd();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Rendering can be configured in two different ways.\r\n     * 1. Using `children`:\r\n     *    * uses context\r\n     *    * supports context based plugins\r\n     * 2. Using `render`:\r\n     *    * better performance\r\n     *\r\n     * The differences are based on the use of context. To allow context based plugins it is advised\r\n     * to use a child function. To improve performance the render property can be used (Plugins can still be used but\r\n     * must be configured manually)\r\n     * @public\r\n     */\r\n    render() {\r\n        const { render, children, anchors } = this.props;\r\n        // Test for either the render property or children to be defined as function.\r\n        // Render wins over children if both are defined. If neither is defined as function, a TypeError is thrown.\r\n        if (typeof render !== \"function\" && typeof children !== \"function\") {\r\n            throw new TypeError(`Either children or render needs to be defined as a function`);\r\n        }\r\n        const { page } = this.state;\r\n        const Wrapper = this.Wrapper;\r\n        // Convert the scrollOffset from percent to a timeline [0,1]\r\n        const progress = this.state.scrollOffset;\r\n        // const {innerHeight} = window;\r\n        // const clippedProgress = Math.round(progress * innerHeight) / innerHeight;\r\n        // Switch between context free and context based versions\r\n        switch (typeof render) {\r\n            case \"function\":\r\n                // Context free\r\n                return (React.createElement(Wrapper, null, render({\r\n                    anchors,\r\n                    page: page + 1,\r\n                    pageIndex: page,\r\n                    pages: this.pageCount,\r\n                    progress\r\n                })));\r\n            // Context based\r\n            default:\r\n                return (React.createElement(ScrollProvider, { value: {\r\n                        anchors,\r\n                        page: page + 1,\r\n                        pageIndex: page,\r\n                        pages: this.pageCount,\r\n                        progress\r\n                    } },\r\n                    React.createElement(Wrapper, null,\r\n                        React.createElement(ScrollConsumer, null, children))));\r\n        }\r\n    }\r\n    static injectStyle() {\r\n        INJECT_CORE_STYLE();\r\n    }\r\n    static getStyleTag() {\r\n        return CORE_STYLE_TAG;\r\n    }\r\n    static getStyle() {\r\n        return CORE_STYLE;\r\n    }\r\n    get pageCount() {\r\n        const { pages } = this.props;\r\n        return Array.isArray(pages) ? pages.length : pages;\r\n    }\r\n    /**\r\n     * @type {React.CSSProperties}\r\n     */\r\n    get wrapperStyle() {\r\n        const { factor } = this.props;\r\n        const vh = this.pageCount * 100 * factor + 100;\r\n        return {\r\n            height: `${vh}vh`\r\n        };\r\n    }\r\n    /**\r\n     * If anchors are defined, a collection of spans with the correct IDs are provided.\r\n     * This allows to link or jump to a section or even skip the entire content.\r\n     * @type {React.ReactElement<HTMLDivElement> | null}\r\n     */\r\n    get anchors() {\r\n        const { anchors } = this.props;\r\n        if (!(typeof anchors === \"string\")) {\r\n            return null;\r\n        }\r\n        const { factor } = this.props;\r\n        const glue = anchors.length ? \"/\" : \"\";\r\n        const targets = Array(this.pageCount)\r\n            .fill(Boolean)\r\n            .map((x, i) => (React.createElement(\"span\", { id: `${anchors}${glue}${i + 1}`, key: `${anchors}:${i + 1}`, className: hashClassNames.target, style: {\r\n                height: `${100 * factor}vh`\r\n            } })));\r\n        return (React.createElement(\"div\", { className: hashClassNames.targets },\r\n            targets,\r\n            React.createElement(\"span\", { id: `${anchors}${glue}${this.pageCount + 1}`, className: hashClassNames.target }),\r\n            React.createElement(\"span\", { id: `${anchors}${glue}skip`, className: hashClassNames.skip })));\r\n    }\r\n}\n\nexport { CORE_STYLE, CORE_STYLE_TAG, Frame, hashClassNames };\n"]},"metadata":{},"sourceType":"module"}